# 52、平时使用算法比较多吗？能简单说下快排的思想吗？时间复杂度是多少？

快速排序的工作原理：  
选择基准值：通常选择数组的第一个元素、最后一个元素或中间元素作为基准。  
分区操作：重新排列数组，使所有比基准值小的元素移到基准前面，所有比基准值大的元素移到基准后面。  
递归排序：递归地将小于基准值的子数组和大于基准值的子数组进行排序。

```c++
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[low];  // 使用第一个元素作为基准
    int i = low + 1;      // i从基准元素的下一个位置开始
    int j = high;
    
    // 循环直到i和j交叉
    while (i <= j) {
        // 找到左边第一个大于基准的元素
        while (i <= j && arr[i] <= pivot) {
            i++;
        }
        // 找到右边第一个小于等于基准的元素
        while (i <= j && arr[j] > pivot) {
            j--;
        }
        if (i < j) {
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[low], arr[j]); // 将基准元素放到正确的位置（j的位置）

    return j;  // 返回基准元素的索引
}

// 快速排序递归函数
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);// 递归排序左半部分
        quickSort(arr, pivotIndex + 1, high);// 递归排序右半部分
    }
}
// 简化调用的重载函数
void quickSort(vector<int>& arr) {
    if (arr.empty()) return;
    quickSort(arr, 0, arr.size() - 1);
}
```
时间复杂度：平均为O(nlogn)，最好为O(nlogn)，最差为O(logn2) 
