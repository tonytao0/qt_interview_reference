# 6、多线程使用使用方法

多线程使用注意事项:<br>
1. 业务对象, 构造的时候不能指定父对象
2. 子线程中不能处理ui窗口(ui相关的类)
3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口 

方法一：继承QThread

1.重写run函数，可在run中写一个while循环体保持运行,使用isInterruptionRequested()比标志量更优
``` c++
class LoopThread : public QThread
{
    Q_OBJECT
protected:
    void run() override {
        qDebug() << "LoopThread started. Thread ID:" << QThread::currentThreadId();
        
        // 无限循环保持线程运行
        while (!isInterruptionRequested()) {
            // 模拟工作
            msleep(1000);
            qDebug() << "LoopThread is running...";
        }
        
        qDebug() << "LoopThread stopped.";
    }
};
```
2.不重写run，线程依旧保持运行，可通过信号与槽来通信

方法二：对象移动到线程中

①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数<br>
②在主线程中创建一QThread类对象<br>
③在主线程中创建一个业务类对象<br>
④将业务类对象移动到子线程中 <br>
⑤在主线程中启动子线程<br>
⑥通过信号槽的方式, 执行业务类中的业务处理函数<br>
```c++
class WorkerObject : public QObject
{
    Q_OBJECT
public slots:
    void startWorking() {
        qDebug() << "WorkerObject started. Thread ID:" << QThread::currentThreadId();
    }
    
    void doWork() {
        qDebug() << "WorkerObject is working...";
    }
};

    QThread eventThread;
    WorkerObject worker;
    worker.moveToThread(&eventThread);
    
    // 连接信号槽，线程启动时执行初始化
    QObject::connect(&eventThread, &QThread::started, &worker, &WorkerObject::startWorking);
    eventThread.start();
```

方法三：线程池，用于短时间并行任务
线程池可自动释放任务对象
```c++
#include <QCoreApplication>
#include <QThreadPool>
#include <QRunnable>
#include <QDebug>
#include <QThread>
#include <QRandomGenerator>

// 定义一个任务类，继承自QRunnable
class WorkerTask : public QRunnable
{
private:
    int m_taskId;

public:
    WorkerTask(int taskId) : m_taskId(taskId) {
        // 设置任务执行完毕后自动删除
        setAutoDelete(true);
    }

    // 重写run()方法，定义任务具体操作
    void run() override {
        qDebug() << "任务" << m_taskId << "开始执行，线程ID:" 
                 << QThread::currentThreadId();

        // 模拟耗时操作
        int sleepTime = QRandomGenerator::global()->bounded(1000, 3000);
        QThread::msleep(sleepTime);

        qDebug() << "任务" << m_taskId << "执行完毕";
    }
};

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    // 获取全局线程池实例
    QThreadPool* threadPool = QThreadPool::globalInstance();
    
    // 配置线程池
    qDebug() << "最大线程数:" << threadPool->maxThreadCount();
    qDebug() << "理想线程数:" << QThread::idealThreadCount();
    
    // 设置最大线程数（可选）
    threadPool->setMaxThreadCount(5);

    // 提交多个任务给线程池
    for (int i = 0; i < 10; ++i) {
        WorkerTask* task = new WorkerTask(i);
        threadPool->start(task); // 提交任务到线程池
    }

    // 等待所有任务完成（对于控制台程序）
    threadPool->waitForDone();
    qDebug() << "所有任务执行完毕";

    return 0;
}

```

