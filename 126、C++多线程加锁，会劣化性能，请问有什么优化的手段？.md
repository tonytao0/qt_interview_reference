# 126、C++多线程加锁，会劣化性能，请问有什么优化的手段？

1. 合理设计程序：尽量减少加锁的次数，把多个操作放到一个加锁的代码段中，减少加锁的次数。

2. 使用原子操作：C++11提供了一些原子操作，比如atomic_compare_exchange_strong()等，可以用来替代锁。利用 CPU 提供的原子指令（如 CAS，Compare-And-Swap）实现无锁同步，适用于简单的计数器、标志位等场景

3. 使用锁的粒度更小的技术：比如读写锁、条件变量等，可以替代普通的互斥锁，减少锁的粒度，提高性能。
 
4. 使用非阻塞技术： 

    >忙等待（Busy Waiting）
    线程在循环中不断检查条件是否满足，不满足时也不阻塞消耗 CPU 资源较多，适用于等待时间极短的场景通常与原子变量配合使用  

    >事件驱动机制：线程通过注册事件监听器等待特定事件，事件发生时触发回调函数，无需主动等待

    >无锁队列无锁栈：基于原子操作实现的复杂数据结构（如无锁队列、无锁栈），多个线程可以同时访问而无需阻塞，需要消耗更多的CPU资源

```c++
#include <atomic>
#include <iostream>

// 节点结构
struct Node {
    int data;
    std::atomic<Node*> next;

    Node(int value) : data(value), next(nullptr) {}
};

// 无锁队列类
class LockFreeQueue {
private:
    // 用原子指针指向头节点和尾节点
    std::atomic<Node*> head;
    std::atomic<Node*> tail;

public:
    LockFreeQueue() {
        // 创建一个哨兵节点作为初始节点
        Node* sentinel = new Node(0);
        head.store(sentinel);
        tail.store(sentinel);
    }

    ~LockFreeQueue() {
        // 释放所有节点
        while (Node* node = head.load()) {
            head.store(node->next.load());
            delete node;
        }
    }

    // 入队操作
    void enqueue(int value) {
        Node* new_node = new Node(value);
        Node* old_tail = nullptr;

        while (true) {
            old_tail = tail.load();
            Node* null_ptr = nullptr;
            
            // 尝试将尾节点的next设为新节点
            if (old_tail->next.compare_exchange_strong(null_ptr, new_node)) {
                break;  // 成功将新节点添加到尾部
            } else {
                // 其他线程已经添加了节点，帮助推进尾指针
                tail.compare_exchange_strong(old_tail, old_tail->next.load());
            }
        }
        
        // 最后更新尾指针指向新节点
        tail.compare_exchange_strong(old_tail, new_node);
    }

    // 出队操作，返回是否成功，结果通过引用参数传出
    bool dequeue(int& result) {
        while (true) {
            Node* old_head = head.load();
            Node* old_tail = tail.load();
            Node* first_node = old_head->next.load();

            // 检查队列是否为空
            if (old_head == old_tail) {
                if (first_node == nullptr) {
                    // 队列为空
                    return false;
                } else {
                    // 帮助推进尾指针
                    tail.compare_exchange_strong(old_tail, first_node);
                }
            } else {
                // 尝试获取第一个节点的数据
                result = first_node->data;
                
                // 尝试更新头指针到第一个节点
                if (head.compare_exchange_strong(old_head, first_node)) {
                    // 成功出队，删除旧的头节点（哨兵）
                    delete old_head;
                    return true;
                }
            }
        }
    }

    // 检查队列是否为空
    bool is_empty() const {
        Node* old_head = head.load();
        Node* old_tail = tail.load();
        return (old_head == old_tail) && (old_head->next.load() == nullptr);
    }
};

// 示例用法
int main() {
    LockFreeQueue queue;

    // 入队操作
    queue.enqueue(10);
    queue.enqueue(20);
    queue.enqueue(30);

    // 出队操作
    int value;
    while (!queue.is_empty()) {
        if (queue.dequeue(value)) {
            std::cout << "Dequeued: " << value << std::endl;
        }
    }

    return 0;
}
```
