# 29、分别写出饿汉和懒汉线程安全的单例模式

​单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。根据单例对象创建时间，可分为两种模式：懒汉模式和饿汉模式。

​懒汉模式：延迟加载，不到万不得已不会去实例化类，也就是说第一次用到类实例的时候才会实例化。

```
#include <iostream>
#include <mutex>
 
using namespace::std;
 
// 懒汉模式一：多线程不安全
class Singleton {
public:
    static Singleton* getInstance() {
        if (instance_ == nullptr) {
            instance_ = new Singleton();
        }
        return instance_;
    }

private:
    Singleton() = default;                        // 构造函数私有
    ~Singleton() = default;
    Singleton(const Singleton&) = delete;         // 禁止拷贝
    Singleton& operator=(const Singleton&) = delete;

private:
    static Singleton* instance_;
};

Singleton* Singleton::instance_ = nullptr;

 
// 懒汉模式二：多线程安全
class Singleton {
private:
    
    Singleton() {}  // 私有构造函数，防止外部实例化
    // 禁用拷贝构造和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton* instance; // 静态指针成员，用于存储唯一实例
    static std::mutex mtx;  // 互斥锁，确保线程安全

public:
    static Singleton* getInstance() {
        // 双重检查锁定 
        if (instance == nullptr) {
            // 加锁，确保只有一个线程进入临界区
            std::lock_guard<std::mutex> lock(mtx);
            // 再次检查，防止多线程同时通过第一次检查
            if (instance == nullptr) {
                instance = new Singleton();
            }
        }
        return instance;
    }
    
    // 销毁单例实例的方法
    static void destroyInstance() {
        std::lock_guard<std::mutex> lock(mtx);
        if (instance != nullptr) {
            delete instance;
            instance = nullptr;
            std::cout << "Singleton instance destroyed" << std::endl;
        }
    }
};

// 初始化静态成员
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;
 
```

 饿汉模式：在单例类定义的时候（即在main函数之前）就进行实例化。因为main函数执行之前，全局作用域的类成员变量instance_已经初始化，故没有多线程的问题。

```
#include <iostream>

// 饿汉模式
class Singleton {
private:
    Singleton() {}

    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton* instance_;
public:
    static Singleton* getInstance() {
        return instance_;   // 直接返回静态指针
    }
};
// 静态成员初始化（程序启动时就创建实例）
Singleton* Singleton::instance_ = new Singleton();

返回引用
class Singleton {
public:
    // 获取单例实例
    static Singleton& getInstance() {
        return instance;
    }

private:
    // 私有构造函数，防止外部创建对象
    Singleton() {}

    // 禁止拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
  
    static Singleton instance;  // 声明静态成员变量建
};
// 类外初始化静态成员变量
Singleton Singleton::instance;
```

